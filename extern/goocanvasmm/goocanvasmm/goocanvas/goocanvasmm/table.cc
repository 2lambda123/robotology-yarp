// Generated by gtkmmproc -- DO NOT MODIFY!


#include <goocanvasmm/table.h>
#include <goocanvasmm/private/table_p.h>

/* Copyright (C) 1998-2006 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */


#include <goocanvastable.h>


namespace Goocanvas
{

void Table::attach(const Glib::RefPtr<Item>& item, guint left_attach, guint right_attach, guint top_attach, guint bottom_attach, Gtk::AttachOptions xoptions, Gtk::AttachOptions yoptions, double left_padding, double right_padding, double top_padding, double bottom_padding)
{
  const gboolean x_expand = (xoptions & Gtk::EXPAND) != 0;
  const gboolean x_fill = (xoptions & Gtk::FILL) != 0;
  const gboolean x_shrink = (xoptions & Gtk::SHRINK) != 0;
  const gboolean y_expand = (yoptions & Gtk::EXPAND) != 0;
  const gboolean y_fill = (yoptions & Gtk::FILL) != 0;
  const gboolean y_shrink = (yoptions & Gtk::SHRINK) != 0;

  add_child(item);
  goo_canvas_item_set_child_properties(GOO_CANVAS_ITEM(gobj()), item->gobj(),
                                       "column", left_attach,
                                       "columns", right_attach - left_attach,
                                       "row", top_attach,
                                       "rows", bottom_attach - top_attach,
                                       "x-fill", x_fill,
                                       "x-expand", x_expand,
                                       "x-shrink", x_shrink,
                                       "y-fill", y_fill,
                                       "y-expand", y_expand,
                                       "y-shrink", y_shrink,
                                       "left-padding", left_padding,
                                       "right-padding", right_padding,
                                       "top-padding", top_padding,
                                       "bottom-padding", bottom_padding,
                                       static_cast<void*>(0));
}

void Table::set_align(const Glib::RefPtr<Item>& child, double xalign, double yalign)
{
  goo_canvas_item_set_child_properties(GOO_CANVAS_ITEM(gobj()), child->gobj(),
                                       "xalign", xalign,
                                       "yalign", yalign,
                                       static_cast<void*>(0));
}

void Table::set_align(const Glib::RefPtr<Item>& child, Gtk::AlignmentEnum xalign, Gtk::AlignmentEnum yalign)
{
  set_align(child, _gtkmm_align_float_from_enum(xalign), _gtkmm_align_float_from_enum(yalign));
}

} //namspace Goocanvas


namespace
{
} // anonymous namespace


namespace Glib
{

Glib::RefPtr<Goocanvas::Table> wrap(GooCanvasTable* object, bool take_copy)
{
  return Glib::RefPtr<Goocanvas::Table>( dynamic_cast<Goocanvas::Table*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Goocanvas
{


/* The *_Class implementation: */

const Glib::Class& Table_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &Table_Class::class_init_function;

    // This is actually just optimized away, apparently with no harm.
    // Make sure that the parent type has been created.
    //CppClassParent::CppObjectType::get_type();

    // Create the wrapper type, with the same class/instance size as the base type.
    register_derived_type(goo_canvas_table_get_type());

    // Add derived versions of interfaces, if the C type implements any interfaces:

  }

  return *this;
}


void Table_Class::class_init_function(void* g_class, void* class_data)
{
  BaseClassType *const klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);


}


Glib::ObjectBase* Table_Class::wrap_new(GObject* object)
{
  return new Table((GooCanvasTable*)object);
}


/* The implementation: */

GooCanvasTable* Table::gobj_copy()
{
  reference();
  return gobj();
}

Table::Table(const Glib::ConstructParams& construct_params)
:
  Goocanvas::Group(construct_params)
{

}

Table::Table(GooCanvasTable* castitem)
:
  Goocanvas::Group((GooCanvasGroup*)(castitem))
{}


Table::~Table()
{}


Table::CppClassType Table::table_class_; // initialize static member

GType Table::get_type()
{
  return table_class_.init().get_type();
}


GType Table::get_base_type()
{
  return goo_canvas_table_get_type();
}


Table::Table()
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(0),
  Goocanvas::Group(Glib::ConstructParams(table_class_.init()))
{
  

}

Glib::RefPtr<Table> Table::create()
{
  return Glib::RefPtr<Table>( new Table() );
}


#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<double> Table::property_row_spacing() 
{
  return Glib::PropertyProxy<double>(this, "row-spacing");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<double> Table::property_row_spacing() const
{
  return Glib::PropertyProxy_ReadOnly<double>(this, "row-spacing");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<double> Table::property_column_spacing() 
{
  return Glib::PropertyProxy<double>(this, "column-spacing");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<double> Table::property_column_spacing() const
{
  return Glib::PropertyProxy_ReadOnly<double>(this, "column-spacing");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<bool> Table::property_homogeneous_rows() 
{
  return Glib::PropertyProxy<bool>(this, "homogeneous-rows");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<bool> Table::property_homogeneous_rows() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "homogeneous-rows");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<bool> Table::property_homogeneous_columns() 
{
  return Glib::PropertyProxy<bool>(this, "homogeneous-columns");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<bool> Table::property_homogeneous_columns() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "homogeneous-columns");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<double> Table::property_x_border_spacing() 
{
  return Glib::PropertyProxy<double>(this, "x-border-spacing");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<double> Table::property_x_border_spacing() const
{
  return Glib::PropertyProxy_ReadOnly<double>(this, "x-border-spacing");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<double> Table::property_y_border_spacing() 
{
  return Glib::PropertyProxy<double>(this, "y-border-spacing");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<double> Table::property_y_border_spacing() const
{
  return Glib::PropertyProxy_ReadOnly<double>(this, "y-border-spacing");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<double> Table::property_vert_grid_line_width() 
{
  return Glib::PropertyProxy<double>(this, "vert-grid-line-width");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<double> Table::property_vert_grid_line_width() const
{
  return Glib::PropertyProxy_ReadOnly<double>(this, "vert-grid-line-width");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<double> Table::property_horz_grid_line_width() 
{
  return Glib::PropertyProxy<double>(this, "horz-grid-line-width");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<double> Table::property_horz_grid_line_width() const
{
  return Glib::PropertyProxy_ReadOnly<double>(this, "horz-grid-line-width");
}
#endif //GLIBMM_PROPERTIES_ENABLED


} // namespace Goocanvas


