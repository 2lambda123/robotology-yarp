// Generated by gtkmmproc -- DO NOT MODIFY!


#include <goocanvasmm/itemmodel.h>
#include <goocanvasmm/private/itemmodel_p.h>

/* Copyright (C) 1998-2006 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <goocanvasmm/canvas.h>
#include <goocanvasitemmodel.h>
#include <goocanvasenumtypes.h>

namespace Goocanvas
{

void ItemModel::raise()
{
  goo_canvas_item_model_raise(gobj(), NULL);
}

void ItemModel::lower()
{
  goo_canvas_item_model_lower(gobj(), NULL);
}

void ItemModel::add_child(const Glib::RefPtr<ItemModel>& child)
{
  goo_canvas_item_model_add_child(gobj(), Glib::unwrap(child), -1);
}

} //namespace Goocanvas

namespace
{


static void ItemModel_signal_child_added_callback(GooCanvasItemModel* self, gint p0,void* data)
{
  using namespace Goocanvas;
  typedef sigc::slot< void,int > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    try
    {
    #endif //GLIBMM_EXCEPTIONS_ENABLED
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0
);
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
    #endif //GLIBMM_EXCEPTIONS_ENABLED
  }
}

static const Glib::SignalProxyInfo ItemModel_signal_child_added_info =
{
  "child-added",
  (GCallback) &ItemModel_signal_child_added_callback,
  (GCallback) &ItemModel_signal_child_added_callback
};


static void ItemModel_signal_child_removed_callback(GooCanvasItemModel* self, gint p0,void* data)
{
  using namespace Goocanvas;
  typedef sigc::slot< void,int > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    try
    {
    #endif //GLIBMM_EXCEPTIONS_ENABLED
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0
);
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
    #endif //GLIBMM_EXCEPTIONS_ENABLED
  }
}

static const Glib::SignalProxyInfo ItemModel_signal_child_removed_info =
{
  "child-removed",
  (GCallback) &ItemModel_signal_child_removed_callback,
  (GCallback) &ItemModel_signal_child_removed_callback
};


static void ItemModel_signal_child_moved_callback(GooCanvasItemModel* self, gint p0,gint p1,void* data)
{
  using namespace Goocanvas;
  typedef sigc::slot< void,int,int > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    try
    {
    #endif //GLIBMM_EXCEPTIONS_ENABLED
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0
, p1
);
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
    #endif //GLIBMM_EXCEPTIONS_ENABLED
  }
}

static const Glib::SignalProxyInfo ItemModel_signal_child_moved_info =
{
  "child-moved",
  (GCallback) &ItemModel_signal_child_moved_callback,
  (GCallback) &ItemModel_signal_child_moved_callback
};


static void ItemModel_signal_changed_callback(GooCanvasItemModel* self, gboolean p0,void* data)
{
  using namespace Goocanvas;
  typedef sigc::slot< void,bool > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    try
    {
    #endif //GLIBMM_EXCEPTIONS_ENABLED
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0
);
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
    #endif //GLIBMM_EXCEPTIONS_ENABLED
  }
}

static const Glib::SignalProxyInfo ItemModel_signal_changed_info =
{
  "changed",
  (GCallback) &ItemModel_signal_changed_callback,
  (GCallback) &ItemModel_signal_changed_callback
};


static void ItemModel_signal_child_notify_callback(GooCanvasItemModel* self, GParamSpec* p0,void* data)
{
  using namespace Goocanvas;
  typedef sigc::slot< void,GParamSpec* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    try
    {
    #endif //GLIBMM_EXCEPTIONS_ENABLED
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
    #endif //GLIBMM_EXCEPTIONS_ENABLED
  }
}

static const Glib::SignalProxyInfo ItemModel_signal_child_notify_info =
{
  "child_notify",
  (GCallback) &ItemModel_signal_child_notify_callback,
  (GCallback) &ItemModel_signal_child_notify_callback
};


static void ItemModel_signal_animation_finished_callback(GooCanvasItemModel* self, gboolean p0,void* data)
{
  using namespace Goocanvas;
  typedef sigc::slot< void,bool > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    try
    {
    #endif //GLIBMM_EXCEPTIONS_ENABLED
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0
);
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
    #endif //GLIBMM_EXCEPTIONS_ENABLED
  }
}

static const Glib::SignalProxyInfo ItemModel_signal_animation_finished_info =
{
  "animation_finished",
  (GCallback) &ItemModel_signal_animation_finished_callback,
  (GCallback) &ItemModel_signal_animation_finished_callback
};


} // anonymous namespace

// static
GType Glib::Value<Goocanvas::AnimateType>::value_type()
{
  return goo_canvas_animate_type_get_type();
}


namespace Glib
{

Glib::RefPtr<Goocanvas::ItemModel> wrap(GooCanvasItemModel* object, bool take_copy)
{
  return Glib::RefPtr<Goocanvas::ItemModel>( dynamic_cast<Goocanvas::ItemModel*> (Glib::wrap_auto_interface<Goocanvas::ItemModel> ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} // namespace Glib


namespace Goocanvas
{


/* The *_Class implementation: */

const Glib::Interface_Class& ItemModel_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Interface_Class has to know the interface init function
    // in order to add interfaces to implementing types.
    class_init_func_ = &ItemModel_Class::iface_init_function;

    // We can not derive from another interface, and it is not necessary anyway.
    gtype_ = goo_canvas_item_model_get_type();
  }

  return *this;
}

void ItemModel_Class::iface_init_function(void* g_iface, void*)
{
  BaseClassType *const klass = static_cast<BaseClassType*>(g_iface);

  //This is just to avoid an "unused variable" warning when there are no vfuncs or signal handlers to connect.
  //This is a temporary fix until I find out why I can not seem to derive a GtkFileChooser interface. murrayc
  g_assert(klass != 0); 

  klass->get_n_children = &get_n_children_vfunc_callback;
  klass->get_child = &get_child_vfunc_callback;
  klass->add_child = &add_child_vfunc_callback;
  klass->move_child = &move_child_vfunc_callback;
  klass->remove_child = &remove_child_vfunc_callback;
  klass->get_child_property = &get_child_property_vfunc_callback;
  klass->set_child_property = &set_child_property_vfunc_callback;
  klass->get_parent = &get_parent_vfunc_callback;
  klass->set_parent = &set_parent_vfunc_callback;
  klass->create_item = &create_item_vfunc_callback;
  klass->get_transform = &get_transform_vfunc_callback;
  klass->set_transform = &set_transform_vfunc_callback;
  klass->get_style = &get_style_vfunc_callback;
  klass->set_style = &set_style_vfunc_callback;

  klass->child_added = &child_added_callback;
  klass->child_removed = &child_removed_callback;
  klass->child_moved = &child_moved_callback;
  klass->changed = &changed_callback;
  klass->child_notify = &child_notify_callback;
  klass->animation_finished = &animation_finished_callback;
}

gint ItemModel_Class::get_n_children_vfunc_callback(GooCanvasItemModel* self)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        // Call the virtual member method, which derived classes might override.
        return obj->get_n_children_vfunc();
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)  );

  // Call the original underlying C function:
  if(base && base->get_n_children)
    return (*base->get_n_children)(self);


  typedef gint RType;
  return RType();
}
GooCanvasItemModel* ItemModel_Class::get_child_vfunc_callback(GooCanvasItemModel* self, gint child_num)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        // Call the virtual member method, which derived classes might override.
        return ((obj->get_child_vfunc(child_num
)) ? (obj->get_child_vfunc(child_num
))->gobj() : 0);
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)  );

  // Call the original underlying C function:
  if(base && base->get_child)
    return (*base->get_child)(self, child_num);


  typedef GooCanvasItemModel* RType;
  return RType();
}
void ItemModel_Class::add_child_vfunc_callback(GooCanvasItemModel* self, GooCanvasItemModel* model, gint position)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        // Call the virtual member method, which derived classes might override.
        obj->add_child_vfunc(Glib::wrap(model, true)
, position
);
        return;
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)  );

  // Call the original underlying C function:
  if(base && base->add_child)
    (*base->add_child)(self, model, position);

}
void ItemModel_Class::move_child_vfunc_callback(GooCanvasItemModel* self, gint old_position, gint new_position)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        // Call the virtual member method, which derived classes might override.
        obj->move_child_vfunc(old_position
, new_position
);
        return;
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)  );

  // Call the original underlying C function:
  if(base && base->move_child)
    (*base->move_child)(self, old_position, new_position);

}
void ItemModel_Class::remove_child_vfunc_callback(GooCanvasItemModel* self, gint child_num)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        // Call the virtual member method, which derived classes might override.
        obj->remove_child_vfunc(child_num
);
        return;
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)  );

  // Call the original underlying C function:
  if(base && base->remove_child)
    (*base->remove_child)(self, child_num);

}
void ItemModel_Class::get_child_property_vfunc_callback(GooCanvasItemModel* self, GooCanvasItemModel* child, guint property_id, GValue* value, GParamSpec* pspec)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        // Call the virtual member method, which derived classes might override.
        obj->get_child_property_vfunc(Glib::wrap(child, true)
, property_id, *reinterpret_cast<Glib::ValueBase*>(value)
, pspec);
        return;
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)  );

  // Call the original underlying C function:
  if(base && base->get_child_property)
    (*base->get_child_property)(self, child, property_id, value, pspec);

}
void ItemModel_Class::set_child_property_vfunc_callback(GooCanvasItemModel* self, GooCanvasItemModel* child, guint property_id, const GValue* value, GParamSpec* pspec)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        // Call the virtual member method, which derived classes might override.
        obj->set_child_property_vfunc(Glib::wrap(child, true)
, property_id, *reinterpret_cast<const Glib::ValueBase*>(value)
, pspec);
        return;
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)  );

  // Call the original underlying C function:
  if(base && base->set_child_property)
    (*base->set_child_property)(self, child, property_id, value, pspec);

}
GooCanvasItemModel* ItemModel_Class::get_parent_vfunc_callback(GooCanvasItemModel* self)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        // Call the virtual member method, which derived classes might override.
        return ((obj->get_parent_vfunc()) ? (obj->get_parent_vfunc())->gobj() : 0);
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)  );

  // Call the original underlying C function:
  if(base && base->get_parent)
    return (*base->get_parent)(self);


  typedef GooCanvasItemModel* RType;
  return RType();
}
void ItemModel_Class::set_parent_vfunc_callback(GooCanvasItemModel* self, GooCanvasItemModel* parent)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        // Call the virtual member method, which derived classes might override.
        obj->set_parent_vfunc(Glib::wrap(parent, true)
);
        return;
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)  );

  // Call the original underlying C function:
  if(base && base->set_parent)
    (*base->set_parent)(self, parent);

}
GooCanvasItem* ItemModel_Class::create_item_vfunc_callback(GooCanvasItemModel* self, GooCanvas* canvas)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        // Call the virtual member method, which derived classes might override.
        return static_cast<GooCanvasItem*>(g_object_ref(Glib::unwrap(obj->create_item_vfunc(Glib::wrap(canvas)
))));
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)  );

  // Call the original underlying C function:
  if(base && base->create_item)
    return (*base->create_item)(self, canvas);


  typedef GooCanvasItem* RType;
  return RType();
}
gboolean ItemModel_Class::get_transform_vfunc_callback(GooCanvasItemModel* self, cairo_matrix_t* transform)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        // Call the virtual member method, which derived classes might override.
        return static_cast<int>(obj->get_transform_vfunc(((Cairo::Matrix*)(transform))
));
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)  );

  // Call the original underlying C function:
  if(base && base->get_transform)
    return (*base->get_transform)(self, transform);


  typedef gboolean RType;
  return RType();
}
void ItemModel_Class::set_transform_vfunc_callback(GooCanvasItemModel* self, const cairo_matrix_t* transform)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        // Call the virtual member method, which derived classes might override.
        obj->set_transform_vfunc(((const Cairo::Matrix*)(transform))
);
        return;
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)  );

  // Call the original underlying C function:
  if(base && base->set_transform)
    (*base->set_transform)(self, transform);

}
GooCanvasStyle* ItemModel_Class::get_style_vfunc_callback(GooCanvasItemModel* self)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        // Call the virtual member method, which derived classes might override.
        return ((obj->get_style_vfunc()) ? (obj->get_style_vfunc())->gobj() : 0);
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)  );

  // Call the original underlying C function:
  if(base && base->get_style)
    return (*base->get_style)(self);


  typedef GooCanvasStyle* RType;
  return RType();
}
void ItemModel_Class::set_style_vfunc_callback(GooCanvasItemModel* self, GooCanvasStyle* style)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        // Call the virtual member method, which derived classes might override.
        obj->set_style_vfunc(Glib::wrap(style, true)
);
        return;
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)  );

  // Call the original underlying C function:
  if(base && base->set_style)
    (*base->set_style)(self, style);

}

void ItemModel_Class::child_added_callback(GooCanvasItemModel* self, gint p0)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        // Call the virtual member method, which derived classes might override.
        obj->on_child_added(p0
);
        return;
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

  // Call the original underlying C function:
  if(base && base->child_added)
    (*base->child_added)(self, p0);
}
void ItemModel_Class::child_removed_callback(GooCanvasItemModel* self, gint p0)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        // Call the virtual member method, which derived classes might override.
        obj->on_child_removed(p0
);
        return;
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

  // Call the original underlying C function:
  if(base && base->child_removed)
    (*base->child_removed)(self, p0);
}
void ItemModel_Class::child_moved_callback(GooCanvasItemModel* self, gint p0, gint p1)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        // Call the virtual member method, which derived classes might override.
        obj->on_child_moved(p0
, p1
);
        return;
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

  // Call the original underlying C function:
  if(base && base->child_moved)
    (*base->child_moved)(self, p0, p1);
}
void ItemModel_Class::changed_callback(GooCanvasItemModel* self, gboolean p0)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        // Call the virtual member method, which derived classes might override.
        obj->on_changed(p0
);
        return;
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

  // Call the original underlying C function:
  if(base && base->changed)
    (*base->changed)(self, p0);
}
void ItemModel_Class::child_notify_callback(GooCanvasItemModel* self, GParamSpec* p0)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        // Call the virtual member method, which derived classes might override.
        obj->on_child_notify(p0);
        return;
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

  // Call the original underlying C function:
  if(base && base->child_notify)
    (*base->child_notify)(self, p0);
}
void ItemModel_Class::animation_finished_callback(GooCanvasItemModel* self, gboolean p0)
{
  Glib::ObjectBase *const obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    CppObjectType *const obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
      #endif //GLIBMM_EXCEPTIONS_ENABLED
        // Call the virtual member method, which derived classes might override.
        obj->on_animation_finished(p0
);
        return;
      #ifdef GLIBMM_EXCEPTIONS_ENABLED
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
      #endif //GLIBMM_EXCEPTIONS_ENABLED
    }
  }
  
  BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

  // Call the original underlying C function:
  if(base && base->animation_finished)
    (*base->animation_finished)(self, p0);
}


Glib::ObjectBase* ItemModel_Class::wrap_new(GObject* object)
{
  return new ItemModel((GooCanvasItemModel*)(object));
}


/* The implementation: */

ItemModel::ItemModel()
:
  Glib::Interface(itemmodel_class_.init())
{}

ItemModel::ItemModel(GooCanvasItemModel* castitem)
:
  Glib::Interface((GObject*)(castitem))
{}

ItemModel::ItemModel(const Glib::Interface_Class& interface_class)
: Glib::Interface(interface_class)
{
}

ItemModel::~ItemModel()
{}

// static
void ItemModel::add_interface(GType gtype_implementer)
{
  itemmodel_class_.init().add_interface(gtype_implementer);
}

ItemModel::CppClassType ItemModel::itemmodel_class_; // initialize static member

GType ItemModel::get_type()
{
  return itemmodel_class_.init().get_type();
}


GType ItemModel::get_base_type()
{
  return goo_canvas_item_model_get_type();
}


int ItemModel::get_n_children() const
{
  return goo_canvas_item_model_get_n_children(const_cast<GooCanvasItemModel*>(gobj()));
}

Glib::RefPtr<ItemModel> ItemModel::get_child(int child_num)
{

  Glib::RefPtr<ItemModel> retvalue = Glib::wrap(goo_canvas_item_model_get_child(gobj(), child_num));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;

}

Glib::RefPtr<const ItemModel> ItemModel::get_child(int child_num) const
{
  return const_cast<ItemModel*>(this)->get_child(child_num);
}

void ItemModel::get_child_property(const Glib::RefPtr<ItemModel>& child, const Glib::ustring& property_name, Glib::ValueBase& value) const
{
goo_canvas_item_model_get_child_property(const_cast<GooCanvasItemModel*>(gobj()), Glib::unwrap(child), property_name.c_str(), (value).gobj()); 
}

void ItemModel::set_child_property(const Glib::RefPtr<ItemModel>& child, const Glib::ustring& property_name, const Glib::ValueBase& value)
{
goo_canvas_item_model_set_child_property(gobj(), Glib::unwrap(child), property_name.c_str(), (value).gobj()); 
}

void ItemModel::add_child(const Glib::RefPtr<ItemModel>& child, int position)
{
goo_canvas_item_model_add_child(gobj(), Glib::unwrap(child), position); 
}

void ItemModel::move_child(int old_position, int new_position)
{
goo_canvas_item_model_move_child(gobj(), old_position, new_position); 
}

void ItemModel::remove_child(int child_num)
{
goo_canvas_item_model_remove_child(gobj(), child_num); 
}

int ItemModel::find_child(const Glib::RefPtr<ItemModel>& child)
{
  return goo_canvas_item_model_find_child(gobj(), Glib::unwrap(child));
}

Glib::RefPtr<ItemModel> ItemModel::get_parent()
{

  Glib::RefPtr<ItemModel> retvalue = Glib::wrap(goo_canvas_item_model_get_parent(gobj()));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;

}

Glib::RefPtr<const ItemModel> ItemModel::get_parent() const
{
  return const_cast<ItemModel*>(this)->get_parent();
}

void ItemModel::set_parent(const Glib::RefPtr<ItemModel>& parent)
{
goo_canvas_item_model_set_parent(gobj(), Glib::unwrap(parent)); 
}

void ItemModel::remove()
{
goo_canvas_item_model_remove(gobj()); 
}

bool ItemModel::is_container() const
{
  return goo_canvas_item_model_is_container(const_cast<GooCanvasItemModel*>(gobj()));
}

void ItemModel::raise(const Glib::RefPtr<ItemModel>& above)
{
goo_canvas_item_model_raise(gobj(), Glib::unwrap(above)); 
}

void ItemModel::lower(const Glib::RefPtr<ItemModel>& below)
{
goo_canvas_item_model_lower(gobj(), Glib::unwrap(below)); 
}

bool ItemModel::get_transform(Cairo::Matrix* transform)
{
  return goo_canvas_item_model_get_transform(gobj(), ((cairo_matrix_t*)(transform)));
}

void ItemModel::set_transform(const Cairo::Matrix* transform)
{
goo_canvas_item_model_set_transform(gobj(), ((const cairo_matrix_t*)(transform))); 
}

void ItemModel::set_simple_transform(double x, double y, double scale, double rotation)
{
goo_canvas_item_model_set_simple_transform(gobj(), x, y, scale, rotation); 
}

bool ItemModel::get_simple_transform(double& x, double& y, double& scale, double& rotation) const
{
  return goo_canvas_item_model_get_simple_transform(const_cast<GooCanvasItemModel*>(gobj()), &(x), &(y), &(scale), &(rotation));
}

void ItemModel::translate(double tx, double ty)
{
goo_canvas_item_model_translate(gobj(), tx, ty); 
}

void ItemModel::scale(double sx, double sy)
{
goo_canvas_item_model_scale(gobj(), sx, sy); 
}

void ItemModel::rotate(double degrees, double cx, double cy)
{
goo_canvas_item_model_rotate(gobj(), degrees, cx, cy); 
}

void ItemModel::skew_x(double degrees, double cx, double cy)
{
goo_canvas_item_model_skew_x(gobj(), degrees, cx, cy); 
}

void ItemModel::skew_y(double degrees, double cx, double cy)
{
goo_canvas_item_model_skew_y(gobj(), degrees, cx, cy); 
}

Glib::RefPtr<Style> ItemModel::get_style()
{

  Glib::RefPtr<Style> retvalue = Glib::wrap(goo_canvas_item_model_get_style(gobj()));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;

}

Glib::RefPtr<const Style> ItemModel::get_style() const
{
  return const_cast<ItemModel*>(this)->get_style();
}

void ItemModel::set_style(const Glib::RefPtr<Style>& style)
{
goo_canvas_item_model_set_style(gobj(), Glib::unwrap(style)); 
}

void ItemModel::animate(double x, double y, double scale, double degrees, bool absolute, int duration, int step_time, AnimateType animate_type)
{
goo_canvas_item_model_animate(gobj(), x, y, scale, degrees, static_cast<int>(absolute), duration, step_time, ((GooCanvasAnimateType)(animate_type))); 
}

void ItemModel::stop_animation()
{
goo_canvas_item_model_stop_animation(gobj()); 
}


Glib::SignalProxy1< void,int > ItemModel::signal_child_added()
{
  return Glib::SignalProxy1< void,int >(this, &ItemModel_signal_child_added_info);
}


Glib::SignalProxy1< void,int > ItemModel::signal_child_removed()
{
  return Glib::SignalProxy1< void,int >(this, &ItemModel_signal_child_removed_info);
}


Glib::SignalProxy2< void,int,int > ItemModel::signal_child_moved()
{
  return Glib::SignalProxy2< void,int,int >(this, &ItemModel_signal_child_moved_info);
}


Glib::SignalProxy1< void,bool > ItemModel::signal_changed()
{
  return Glib::SignalProxy1< void,bool >(this, &ItemModel_signal_changed_info);
}


Glib::SignalProxy1< void,GParamSpec* > ItemModel::signal_child_notify()
{
  return Glib::SignalProxy1< void,GParamSpec* >(this, &ItemModel_signal_child_notify_info);
}


Glib::SignalProxy1< void,bool > ItemModel::signal_animation_finished()
{
  return Glib::SignalProxy1< void,bool >(this, &ItemModel_signal_animation_finished_info);
}


#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy< Glib::RefPtr<ItemModel> > ItemModel::property_parent() 
{
  return Glib::PropertyProxy< Glib::RefPtr<ItemModel> >(this, "parent");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly< Glib::RefPtr<ItemModel> > ItemModel::property_parent() const
{
  return Glib::PropertyProxy_ReadOnly< Glib::RefPtr<ItemModel> >(this, "parent");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<bool> ItemModel::property_can_focus() 
{
  return Glib::PropertyProxy<bool>(this, "can-focus");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<bool> ItemModel::property_can_focus() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "can-focus");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<Cairo::Matrix*> ItemModel::property_transform() 
{
  return Glib::PropertyProxy<Cairo::Matrix*>(this, "transform");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<Cairo::Matrix*> ItemModel::property_transform() const
{
  return Glib::PropertyProxy_ReadOnly<Cairo::Matrix*>(this, "transform");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<Glib::ustring> ItemModel::property_title() 
{
  return Glib::PropertyProxy<Glib::ustring>(this, "title");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<Glib::ustring> ItemModel::property_title() const
{
  return Glib::PropertyProxy_ReadOnly<Glib::ustring>(this, "title");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<Glib::ustring> ItemModel::property_description() 
{
  return Glib::PropertyProxy<Glib::ustring>(this, "description");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<Glib::ustring> ItemModel::property_description() const
{
  return Glib::PropertyProxy_ReadOnly<Glib::ustring>(this, "description");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<PointerEvents> ItemModel::property_pointer_events() 
{
  return Glib::PropertyProxy<PointerEvents>(this, "pointer-events");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<PointerEvents> ItemModel::property_pointer_events() const
{
  return Glib::PropertyProxy_ReadOnly<PointerEvents>(this, "pointer-events");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<ItemVisibility> ItemModel::property_visibility() 
{
  return Glib::PropertyProxy<ItemVisibility>(this, "visibility");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<ItemVisibility> ItemModel::property_visibility() const
{
  return Glib::PropertyProxy_ReadOnly<ItemVisibility>(this, "visibility");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<double> ItemModel::property_visibility_threshold() 
{
  return Glib::PropertyProxy<double>(this, "visibility-threshold");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<double> ItemModel::property_visibility_threshold() const
{
  return Glib::PropertyProxy_ReadOnly<double>(this, "visibility-threshold");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<double> ItemModel::property_x() 
{
  return Glib::PropertyProxy<double>(this, "x");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<double> ItemModel::property_x() const
{
  return Glib::PropertyProxy_ReadOnly<double>(this, "x");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<double> ItemModel::property_y() 
{
  return Glib::PropertyProxy<double>(this, "y");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<double> ItemModel::property_y() const
{
  return Glib::PropertyProxy_ReadOnly<double>(this, "y");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<double> ItemModel::property_width() 
{
  return Glib::PropertyProxy<double>(this, "width");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<double> ItemModel::property_width() const
{
  return Glib::PropertyProxy_ReadOnly<double>(this, "width");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy<double> ItemModel::property_height() 
{
  return Glib::PropertyProxy<double>(this, "height");
}
#endif //GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<double> ItemModel::property_height() const
{
  return Glib::PropertyProxy_ReadOnly<double>(this, "height");
}
#endif //GLIBMM_PROPERTIES_ENABLED


void Goocanvas::ItemModel::on_child_added(int child_num)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->child_added)
    (*base->child_added)(gobj(),child_num);
}
void Goocanvas::ItemModel::on_child_removed(int child_num)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->child_removed)
    (*base->child_removed)(gobj(),child_num);
}
void Goocanvas::ItemModel::on_child_moved(int old_child_num, int new_child_num)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->child_moved)
    (*base->child_moved)(gobj(),old_child_num,new_child_num);
}
void Goocanvas::ItemModel::on_changed(bool recompute_bounds)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->changed)
    (*base->changed)(gobj(),static_cast<int>(recompute_bounds));
}
void Goocanvas::ItemModel::on_child_notify(GParamSpec* pspec)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->child_notify)
    (*base->child_notify)(gobj(),pspec);
}
void Goocanvas::ItemModel::on_animation_finished(bool stopped)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->animation_finished)
    (*base->animation_finished)(gobj(),static_cast<int>(stopped));
}

int Goocanvas::ItemModel::get_n_children_vfunc() const
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->get_n_children)
    return (*base->get_n_children)(const_cast<GooCanvasItemModel*>(gobj()));

  typedef int RType;
  return RType();
}
Glib::RefPtr<ItemModel> Goocanvas::ItemModel::get_child_vfunc(int child_num) const
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->get_child)
    return Glib::wrap((*base->get_child)(const_cast<GooCanvasItemModel*>(gobj()),child_num), true);

  typedef Glib::RefPtr<ItemModel> RType;
  return RType();
}
void Goocanvas::ItemModel::add_child_vfunc(const Glib::RefPtr<ItemModel>& child, int position) 
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->add_child)
    (*base->add_child)(gobj(),Glib::unwrap(child),position);
}
void Goocanvas::ItemModel::move_child_vfunc(int old_position, int ne_position) 
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->move_child)
    (*base->move_child)(gobj(),old_position,ne_position);
}
void Goocanvas::ItemModel::remove_child_vfunc(int child_num) 
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->remove_child)
    (*base->remove_child)(gobj(),child_num);
}
void Goocanvas::ItemModel::get_child_property_vfunc(const Glib::RefPtr<ItemModel>& child, guint property_id, Glib::ValueBase& value, GParamSpec* pspec) const
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->get_child_property)
    (*base->get_child_property)(const_cast<GooCanvasItemModel*>(gobj()),Glib::unwrap(child),property_id,(value).gobj(),pspec);
}
void Goocanvas::ItemModel::set_child_property_vfunc(const Glib::RefPtr<ItemModel>& child, guint property_id, const Glib::ValueBase& value, GParamSpec* pspec) 
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->set_child_property)
    (*base->set_child_property)(gobj(),Glib::unwrap(child),property_id,(value).gobj(),pspec);
}
Glib::RefPtr<ItemModel> Goocanvas::ItemModel::get_parent_vfunc() const
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->get_parent)
    return Glib::wrap((*base->get_parent)(const_cast<GooCanvasItemModel*>(gobj())), true);

  typedef Glib::RefPtr<ItemModel> RType;
  return RType();
}
void Goocanvas::ItemModel::set_parent_vfunc(const Glib::RefPtr<ItemModel>& parent) 
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->set_parent)
    (*base->set_parent)(gobj(),Glib::unwrap(parent));
}
Glib::RefPtr<Item> Goocanvas::ItemModel::create_item_vfunc(Canvas* canvas) 
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->create_item)
    return Glib::wrap((*base->create_item)(gobj(),(canvas)->gobj()), false);

  typedef Glib::RefPtr<Item> RType;
  return RType();
}
bool Goocanvas::ItemModel::get_transform_vfunc(Cairo::Matrix* transform) const
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->get_transform)
    return (*base->get_transform)(const_cast<GooCanvasItemModel*>(gobj()),((cairo_matrix_t*)(transform)));

  typedef bool RType;
  return RType();
}
void Goocanvas::ItemModel::set_transform_vfunc(const Cairo::Matrix* transform) 
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->set_transform)
    (*base->set_transform)(gobj(),((const cairo_matrix_t*)(transform)));
}
Glib::RefPtr<Style> Goocanvas::ItemModel::get_style_vfunc() const
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->get_style)
    return Glib::wrap((*base->get_style)(const_cast<GooCanvasItemModel*>(gobj())), true);

  typedef Glib::RefPtr<Style> RType;
  return RType();
}
void Goocanvas::ItemModel::set_style_vfunc(const Glib::RefPtr<Style>& style) 
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->set_style)
    (*base->set_style)(gobj(),Glib::unwrap(style));
}


} // namespace Goocanvas


