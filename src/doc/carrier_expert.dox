
/** 
 * @page carrier_expert Creating carriers for new kinds of connections

\author Paul Fitzpatrick

In YARP, ports talk to each other via connections.  Types of connections
are called "carriers".  See \ref carrier_config for information about
how to configure connections using existing carriers.  Here, we are going
to look at creating new kinds of carriers.  Why might you want to do this?

 \li You need to use a kind of network that YARP doesn't 
     currently support.  For example, we don't currently have
     support for QNX message passing (even though, years ago, that
     was the very first carrier supported by YARP - we remember it
     fondly).

 \li You don't like some aspect of YARP's current carriers.  No problem,
     just make your own variation and plug it in.  (Please call it a 
     different name though so as not to destroy the possibility of
     interoperation).  If it works well, please consider telling us 
     about it.

 \li You want to support network-level interoperation with non-YARP based
     programs.

\section carrier_expert_preliminaries Coding preliminaries

The implementation of carriers is in the namespace yarp::os::impl,
rather than the regular namespace yarp::os.  Be warned that classes in
the yarp::os::impl ("implementation") namespace may change more from
release to release than those in yarp::os (intended to be a stable
user API).

Header files for implementation classes may have dependencies on 
header files from the ACE library.  This means that you need
to take some care to make sure that the ACE header files on your
system match those used to compile YARP.  

\section carrier_expert_classes Important classes

You should skim the documentation of the following classes:

 \li yarp::os::impl::Carrier
 \li yarp::os::impl::Carriers

You'll be able to include them in your code as follows:

\code
#include <yarp/os/impl/Carrier.h>
#include <yarp/os/impl/Carriers.h>
using namespace yarp::os::impl;
\endcode

\section carrier_expert_basics The basics

A few things you need to know.  An important property of YARP carriers is that they do not need
to be constant throughout a connection.  So, for example, a connection may begin using a TCP
carrier (and in practice all connections currently do in fact start with TCP, though this is not
required), and then switch to something more efficient after some handshaking. So watch out for 
that.  In the \ref yarp_guts "YARP Guts" tutorial, you can see a little more
how a carrier and connections relate.

When a port is registered with the YARP name server, an initial carrier type is specified.
For example, the port associated with the name server itself might be registered as:

\verbatim
  registration name /root ip 192.168.1.3 port 10000 type tcp
\endverbatim

The "tcp" type specified there does not necessarily mean that this port can only accept "tcp" carriers,
it just means that that is how one should begin a connection to this port.

The first eight bytes sent on a connection are special in YARP.  They act as a "magic number"
for identifying the carrier to switch to.  Some flags for identifying variants of a carrier
might be included as well.  This is a lot like how common file formats work and other network
protocols work.  See \ref yarp_protocol for a table of "official" YARP magic numbers.

Once you've made up a new eight-byte sequence to name your new
carrier, you then have a huge amount of freedom in how it works.  The
abstract phases of YARP communication are specified, but their
representation "on the wire" is basically up to you.  This means you
have a decent shot at matching some other protocol you might have to
interface with.  Even the required eight-byte sequence requirement can
be loosened, with a bit of care.

\section carrier_expert_example A first example

Here is a example that takes an existing carrier, the \ref carrier_config_text "ordinary text-mode carrier", and modifies it slightly (see example/carrier/carrier_stub.cpp).  The change is very small; we name our new carrier "test" (as 
opposed to "text") and change its identifying 8-byte header from 
"CONNECT " to "TESTTEST".

\include example/carrier/carrier_stub.cpp

The key steps are:

 \li We create a new class for our new carrier, by subclassing something descended from yarp::os::impl::Carrier (in this case yarp::os::impl::TextCarrier).

 \li We make whatever customizations we want to that carrier.  It is very
 important to override the "factory" method Carrier::create to return
 an instance of our new class.  We also define the name associated with
 our class by overriding Carrier::getName.

 \li At the start of our program, we register an instance of that class 
 in a call to Carriers::addCarrierPrototype.

Having taken those steps, we can make connections using our new carrier
(called "test" in the example code):

\code
Network::connect(...,...,"test");
\endcode

To make connections of this type from the command line with the 
\ref yarp "yarp companion" (the "yarp" command), you need to insert your 
carrier in the YARP library, or else compile a customized version of 
the companion.  Here is the companion's source code in its entirety:

\code
#include <yarp/os/Network.h>
using namespace yarp::os;
int main(int argc, char *argv[]) {
    Network yarp;
    return Network::main(argc,argv);
}
\endcode

So there isn't much to it to just insert a call to 
Carriers::addCarrierPrototype in there.  Otherwise, to put
the new carrier in the YARP library proper, do a little pattern-matching
in the constructor for the yarp::os::impl::Carriers class
at src/libYARP_OS/src/Carriers.cpp.



*/

