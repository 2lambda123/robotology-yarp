/*
 * Copyright (C) 2010 Paul Fitzpatrick
 * CopyPolicy: Released under the terms of the GNU GPL v2.0.
 *
 */

/**
 * @page add_a_plugin Add a plugin to YARP
 *

\author Paul Fitzpatrick

THIS PAGE IS INCOMPLETE, APOLOGIES...

In YARP, a "plugin" is an implementation of some service for which
there are many choices and alternatives.  There are two basic types of
plugin for YARP: devices and carriers.  Devices implement 
interfaces to cameras, controlboards, and other hardware.  Carriers 
implement different network protocols.  Users select which devices
and carriers they want to have included in YARP (or they can compile
them separately).

Optional devices and carriers are enabled or disabled via CMake options.
Enabling a device or carrier may require extra libraries to be installed.

Before discussing how to add new devices or carriers into the YARP library
itself, we look at how a user can make their own library of plugins.
This is a useful first step in getting confident about how plugins work.

\section add_a_plugin_single Making a single plugin

Let's take the FakeFrameGrabber example device developed in \ref note_devices
and turn it into a plugin.  Make a directory called "fake_grabber"
(or whatever you like), and add the following
as "fake_grabber/FakeFrameGrabber.h".

\code
#include <yarp/os/all.h>
#include <yarp/dev/all.h>
class FakeFrameGrabber : public IFrameGrabberImage, 
			 public yarp::dev::DeviceDriver {
private:
    int w, int h;
public:
    FakeFrameGrabber() {
	h = w = 0;
    }

    bool open(int w, int h) {
	this->w = w;
	this->h = h;
	return w>0 && h>0;
    }

    virtual bool open(yarp::os::Searchable& config) { 
	// extract width and height configuration, if present
	// otherwise use 128x128
	int desiredWidth = config.check("w",Value(128)).asInt();
	int desiredHeight = config.check("h",Value(128)).asInt();
	return open(desiredWidth,desiredHeight);
    }

    virtual bool close() { 
	return true; // easy
    }

    virtual bool getImage(yarp::sig::ImageOf<yarp::sig::PixelRgb>& image);

    virtual int height() const {
	return h;
    }

    virtual int width() const {
	return w;
    }
};
\endcode

And add this as "fake_grabber/FakeFrameGrabber.cpp":

\code
#include "FakeFrameGrabber.h"
using namespace yarp::os;
using namespace yarp::sig;
using namespace yarp::dev;
bool FakeFrameGrabber::getImage(ImageOf<PixelRgb>& image) {
	Time::delay(0.5);  // simulate waiting for hardware to report
	image.resize(w,h);
	image.zero();
	return true;
}
\endcode

YARP plugins need a CMakeLists.txt that says how to build them.  The
CMakeLists.txt is written in the following style:

\verbatim
  if (COMPILE_PLUGIN_LIBRARY)
    # Declare a device called "foo", with C++ type "FooDriver" defined
    # in FooDriver.h.  This code sets up an CMake option, and prepares
    # some initialization boilerplate code if needed.
    # If the device is not selected, "SKIP_foo" will be defined.
    PREPARE_PLUGIN(fake_grabber CATEGORY device TYPE FakeFrameGrabber INCLUDE FakeFrameGrabber.h WRAPPER grabber)
  endif (COMPILE_DEVICE_LIBRARY)
  if (NOT SKIP_foo)
    # Find any libraries needed - just YARP for this example
    find_package(YARP REQUIRED)
    include_directories(${YARP_INCLUDE_DIRS})
    # ... find and use other needed libraries ...
    add_library(fake_grabber FakeFrameGrabber.cpp FakeFrameGrabber.h)
    target_link_libraries(fake_grabber ${YARP_LIBRARIES})
    if (NOT COMPILE_PLUGIN_LIBRARY)
      add_executable(test_fake_grabber test_fake_grabber.cpp)
      target_link_libraries(test_fake_grabber fake_grabber)
    endif (NOT COMPILE_DEVICE_LIBRARY)
  endif (NOT SKIP_foo)
\endverbatim

This style is used so that individual plugin directories can be
compiled standalone for testing purposes, but will also work
when bundled into a larger library.

\section add_a_plugin_userlib Making a plugin library

Here we put together a library of YARP plugins from scratch.

First, let's start with a test program, test_userlib.cpp:
\code
#include <stdio.h>
int main(int argc, char *argv[]) {
  printf("Test program stub\n");
  return 0;
}
\endcode

\verbatim
cmake_minimum_required(VERSION 2.6)
find_package(YARP REQUIRED)
include_directories(${YARP_INCLUDE_DIRS})
add_executable(test_userlib test_userlib.cpp)
target_link_libraries(test_userlib ${YARP_LIBRARIES})
\endverbatim

Now, let's prepare a plugin library.  We need to include
${YARP_MODULE_PATH}/YarpPlugin.cmake in order to get some 
helper functions for this:

\verbatim
cmake_minimum_required(VERSION 2.6)
find_package(YARP REQUIRED)
include_directories(${YARP_INCLUDE_DIRS})
include(${YARP_MODULE_PATH}/YarpPlugin.cmake)
begin_plugin_library(userlib)
# nothing in the library yet
end_plugin_library(userlib)
add_executable(test_userlib test_userlib.cpp)
target_link_libraries(test_userlib ${YARP_LIBRARIES})
target_link_libraries(test_userlib userlib)
\endverbatim

 *
 */