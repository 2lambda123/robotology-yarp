/*
 * Copyright (C) 2010 RobotCub Consortium
 * CopyPolicy: Released under the terms of the LGPLv2.1 or later, see LGPL.TXT
 *
 */

/** 
 * @page yarp_build_structure YARP's own build structure

@author Paul Fitzpatrick

*** under construction ***
*** insert animated gif of man digging ***

For the reference of YARP developers, and the curious, here is a 
sketch of how YARP builds, including plugins.

The YARP project is profoundly grateful to the creators of CMake,
for finally giving us a sane way to build a cross-platform library.

@section yarp_build_structure_big Some big picture notes

Before getting into the details, here are a few general notes on YARP's 
source code and build:
\li YARP is often used without installation.  It can be used either
directly from its build directory ("in-tree use"), or via an install.
\li Although not required, YARP is designed with out-of-source builds
in mind.  The description from here on assumes you are doing that.
\li Each YARP library has its own set of header files, kept 
separate in the source but laid out so that they can be folded together
after installation.  By convention, YARP header files are accessed
from C++ as "#include <yarp/os/...>", "#include <yarp/sig/...>" etc.
The header file locations are chosen
to allow the difference between in-tree and installed operation to
be hidden.  For in-tree use, we have an include path of 
src/libYARP_OS/include, src/libYARP_sig/include, ...  For installed 
use, the include path collapses to just one directory, [prefix]/include.
This is the reason for the apparent redundancy in header file paths,
e.g. src/libYARP_OS/include/yarp/os/Port.h - it seems strange
to have to include "yarp" and "os" in when compiling "libYARP_OS", but
in the big picture it makes sense.
\li Header files in "impl" directories are not intended for use outside
of YARP.  They are accessible during in-tree use, but not after installation.
If there's a good reason to install them, let us know though!
\li YARP uses ACE in its implementation, but does not expose that use in any
public header files (anything not in an "impl" directory).  Doing so 
causes all sorts of arcane problems.  YARP developers should take care to
maintain this constraint.
\li YARP uses no standard C++ libraries in its core libraries.  STL is not
used, nor is fstream/iostream/...  Nor are exceptions used.  YARP developers 
should take care to maintain this constraint.  (ACE in turn
can be compiled under the same constraints).
\li *Users* of YARP are of course free to use the STL, exceptions,
and all the goodies.  In fact, they should.  That's a separate issue from
what a library that aims at being portable (especially in binary form)
should do.
\li Documentation is produced using doxygen.  Extended tutorials like this
one are to be found in src/doc/[filename].dox, where the filename should
generally match the name before .html you see in your browsers.

@section yarp_build_structure_index (Partial) index
<ul>
<li> \ref yarp_build_structure_main
<li> conf
  <ul>
  <li> \ref yarp_build_structure_conf
  <li> \ref yarp_build_structure_options
  <li> \ref yarp_build_structure_version
  <li> \ref yarp_build_structure_system_check
  <li> \ref yarp_build_structure_describe
  <li> \ref yarp_build_structure_package
  <li> \ref yarp_build_structure_doc
  <li> \ref yarp_build_structure_plugin
  <li> conf/templates
  </ul>
<li> src
  <ul>
  <li> \ref yarp_build_structure_src
  <li> src/libYARP_OS
    <ul>
    <li> \ref yarp_build_structure_yarpos
    </ul>
  <li> src/libYARP_sig
    <ul>
    <li> \ref yarp_build_structure_yarpsig
    </ul>
  <li> src/libYARP_math
    <ul>
    <li> \ref yarp_build_structure_yarpmath
    </ul>
  <li> src/libYARP_dev
    <ul>
    <li> \ref yarp_build_structure_yarpdev
    </ul>
  <li> src/modules
    <ul>
    <li> \ref yarp_build_structure_modules
    </ul>
  </ul>
</ul>

@section yarp_build_structure_main The main CMakeLists.txt

The main CMakeLists.txt file for YARP is simple. It does the following:
 \li Sets the CMAKE_MODULE_PATH to pick up scripts in the "conf" directory.
 \li Initializes some empty lists: YARP_TREE_INCLUDE_DIRS, YARP_LIBS, YARP_DEFS. These will be used to keep track of paths to header files, names of library targets, and extra compiler definitions needed.
 \li Includes the \ref yarp_build_structure_options "conf/YarpOptions.cmake" file, to define general configuration options.
 \li Includes the \ref yarp_build_structure_version "conf/YarpVersion.cmake" file, to define the current YARP version.
 \li Includes the \ref yarp_build_structure_system_check "conf/YarpSystemCheck.cmake" file, to get properties of the system YARP is being compiled on.
 \li Enables the CMake "test" target.
 \li Enters the \ref yarp_build_structure_conf "conf" directory for some preliminary code generation.
 \li Enters the \ref yarp_build_structure_src "src" directory to set up compilation targets.
 \li Includes the \ref yarp_build_structure_describe "conf/YarpDescribe.cmake" file, to store information about how YARP is configured.  This is important to make YARP easier to use from external projects.
 \li Includes the \ref yarp_build_structure_package "conf/YarpPackage.cmake" file, which sets up targets for packaging YARP as a tarball, zip, etc.
 \li Includes the \ref yarp_build_structure_doc "conf/YarpDoc.cmake" file, which sets up a target for generating YARP's documentation.

And we're done!

There are a few lines at the bottom of the CMakeLists.txt file that look
like this:
\verbatim
# Modify this file when you add/remove files in directories that
# are scanned for sources.  This will make sure that cmake gets rerun
# for everybody.
# Touch: 1 2 3
\endverbatim
When new source files are added to YARP, and no CMakeLists.txt file is
modified in so doing, it is wise to add another arbitrary number to 
the "Touch" line.  We've been lazy in YARP and let CMake scan for 
source files rather than listing them all explicitly.  Without the
"touch" line, users could end up with broken builds if they do an "svn update",
receive a new source file added by someone else, and don't run cmake.

@section yarp_build_structure_options conf/YarpOptions.cmake

First we set up:
 \li The CMake LIBRARY_OUTPUT_PATH variable (set to the "lib" directory).
 \li The CMake EXECUTABLE_OUTPUT_PATH variable (set to the "bin" directory).
 \li The CMake CMAKE_BUILD_TYPE variable (debug, release, etc).

[ADVANCED] Then we check if the "static_libs" directory exists.  If
so, any static libraries within it are unconditionally linked.  This
is handy for building stand-alone binaries that link everything they
need.  Done carefully, such binaries can be used on different machines
in the same general OS family.

Now we prepare some options for the user.  Some may be hidden
as "advanced" options.
\li The CREATE_SHARED_LIBRARY option - if set to true, shared libraries
 (.so/.dll/.dylib/...) will be built, instead of static.
\li [ADVANCED] The USE_STL_STRING option - internally, YARP uses an 
 ACE string class.  This can be toggled to std::string if desired.
\li [ADVANCED] The CREATE_BUILTIN_DEVICE_TESTS option - normally, YARP 
 won't test devices, but if you turn this flag on it will attempt some
 device tests.  This has the side-benefit of being useful for building 
 documentation about those devices, by probing their "open" method with 
 verbose turned on.
\li The ENABLE_DASHBOARD_SUBMIT flag - if enabled, builds and tests can
 be submitted to the YARP online dashboard.
\li The COMPILING_ALL_YARP flag - this is always true, and is there so
 that any YARP plugin can determine that it is currently being compiled as 
 part of YARP.

@section yarp_build_structure_version conf/YarpVersion.cmake

This is a very simple file, defining a version number for YARP.
YARP versioning is as follows:
\li YARP_VERSION_MAJOR - has only changed once or twice, ever.
\li YARP_VERSION_MINOR - changes perhaps once every year or two.
\li YARP_VERSION_PATCH - changes with every release.
\li YARP_VERSION_MODIFIER - rarely used, other than to signal unofficial release candidates.

@section yarp_build_structure_system_check conf/YarpSystemCheck.cmake

Here we probe for some system properties needed to compile YARP correctly.
We set up compiler flags reflecting those properties.
\li We set YARP_BIG_ENDIAN/YARP_LITTLE_ENDIAN depending on the order
of bytes in integers.  For example, if the number 42, expressed as a 
four byte integer is "42 0 0 0", then YARP_LITTLE_ENDIAN is set.
If instead it is "0 0 0 42", then YARP_BIG_ENDIAN is set.  This
will affect the implementation of the yarp::os::NetInt32 type.
On little endian systems, NetInt32 maps straight onto native integers.
On big endian systems, NetInt32 is a class that simulates little endian
integers.
\li We figure out an appropriate native type for 16-bit integers,
32-bit integers, and 64-bit floating point numbers.  The types are stored
in YARP_INT16, YARP_INT32, and YARP_FLOAT64 respectively.
\li If the YARP_ADMIN environment flag is set, we turn on some more 
aggressive warnings and errors in the compiler.  YARP developers should
generally have this flag set if possible.
\li We define YARP_PRESENT for compilation.  This definition is unused.
\li We define _REENTRANT, for thread-safe C library calls.
\li Compiler flags that may also be needed by users are recorded in a 
 global property "YARP_DEFS" for later export.
\li If on Windows, compiling natively, we make sure WIN32 and _WINDOWS are set (ACE relies on them).
\li If on Windows, compiling under Cygwin, we define CYGWIN (ACE needs this).
\li If using MINGW and/or MSYS, we set appropriate flags.
\li We attempt to locate the ACE library using the conf/FindACE.cmake script.
\li We check whether the type ACE_String_Base_Const::size_type exists. Older
ACE versions didn't have this type, newer versions do.  If it is present,
it must be used, but there's no obvious way to check for it in code,
so we need to explicitly test for it.
\li Under MSVC, we turn off a set of warnings that ACE triggers.  The warnings
are for deprecated functions that ACE provides wrappers for.
\li Under MSVC, we set CMAKE_DEBUG_POSTFIX to "d", to add "d" to library 
names in debug mode.  This is just a convention.

@section yarp_build_structure_conf conf/CMakeLists.txt

Here we generate some header files to hold configuration options.
\li A subdirectory "generated_include" of the build directory is created.
We add that directory to "YARP_TREE_INCLUDE_DIRS", which will
become a list of the paths to all header files needed by YARP.
\li We instantate conf/template/yarp_config_options.h.in in generated_include/yarp/conf/yarp_config_options.h.  This holds general compile options.
\li We instantate conf/template/yarp_config_version.h.in in generated_include/yarp/conf/yarp_config_version.h.  This holds a representation of the YARP version number.
\li We instantate conf/template/yarp_config_system.h.in in generated_include/yarp/conf/yarp_config_system.h.  This holds some facts about the system upon which YARP is being built.
\li We copy many macros from the "conf" directory in the source to a "conf" directory in the build, since they may be useful for users (library find scripts etc).

@section yarp_build_structure_src src/CMakeLists.txt

This file is a simple list of subdirectories, for all the parts of YARP.
At the time of writing, these are the following - libraries first:
\li \ref yarp_build_structure_yarpos "libYARP_OS" - this contains the basic YARP implementation of ports,
threads, etc.
\li \ref yarp_build_structure_yarpsig "libYARP_sig" - signal processing: images, sound, vectors, and the like.
Intended mostly to be easy to connect with other libraries (e.g. OpenCV).
\li \ref yarp_build_structure_yarpmath "libYARP_math" - an optional wrapper around the GNU Scientific Library.
\li \ref yarp_build_structure_yarpdev "libYARP_dev" - device management.
(license note: the GSL is under the GPL, not the LGPL, so enabling this 
option places YARP under the GPL).
\li \ref yarp_build_structure_modules "modules" - optional plugin devices (some under non-LGPL licenses).
\li carriers - optional plugin network protocols.
\li libYARP_init - a tiny wrapper that initializes all optional modules 
and carriers.
\li libyarpc - an experimental C API to YARP.
\li libyarpcxx - an experimental C++ interface to YARP that is a simple
wrapper around libyarpc.  These two experimental libraries together make
it easier to build very portable binary libraries for YARP.

And then executables:
\li yarp - the main command line interface to YARP.
\li yarpserver - home of the experimental yarpserver3 program, a YARP
name server based on Sqlite.
\li yarprun - a tool for starting/stopping programs across the network.
\li yarpview - a viewer for YARP image streams.
\li yarphear - a way to listen to YARP audio streams.
\li yarpdev - the main command line interface for YARP devices.

And finally tests:
\li tests - this directory pulls in regression tests from throughout the
build.

@section yarp_build_structure_describe conf/YarpDescribe.cmake

Our job here is to capture everything a project that uses YARP will 
need to know, and export that.  We need to deal with two important 
cases: where YARP is used directly from its build directory 
(without an install), or where YARP is installed in system directories.

First we set up some variables:
\li We set YARP_INCLUDES from the global property YARP_TREE_INCLUDE_DIRS.
All libraries configured to build will have appended the *internal* paths 
they need here.  These paths are important for using YARP without an 
install.
\li We set YARP_LIBRARIES from the global property YARP_LIBS.  All libraries
configured to build will have appended their target name here.
\li We set YARP_ALL_DEFINES from the global property YARP_DEFS.  This has
any special compiler flags needed by the configured build.
\li We set YARP_HAS_MATH_LIB to true if the math library was configured to
build.

We now generate three files in the build directory:
\li YARPConfig.cmake - this is an important file for using YARP directly
from its build directory without an install.  If the YARP_DIR environment
variable is set to the build directory, A CMake
call to "FIND_PACKAGE(YARP)" will find this file and 
pull in everything it needs to know about YARP.
The template for this file is conf/template/YARPConfig.cmake.in. 
It stores the variables we set up above, tries to read YARPDependencies.cmake
(see next file), and does some backwards-compatibility gymnastics.
\li YARPDependencies.cmake - this contains information about the dependencies
of all YARP targets.  It is generated by the CMake "EXPORT" command.
\li YARPConfigForInstall.cmake - this is an alternate version of 
YARPConfig.cmake, appropriate after an install. After installation, it would 
be placed into [prefix]/lib/YARP/YARPConfig.cmake.  An equivalent of 
YARPDependencies.cmake would also be generated upon an installation, in
[prefix]/lib/YARP/YARP.cmake.  This is generated using the CMake
"INSTALL(EXPORT ...)" command
Again, these are locations that 
"FIND_PACKAGE(YARP)" can pick up automatically.

@section yarp_build_structure_package conf/YarpPackage.cmake 

CMake comes with a companion utility CPack for generating tarballs,
zip files, Windows installers, etc.  This file sets some simple
variables (project name, version number, license, etc) and puts CPack
to work.  The line "INCLUDE(CPack)" creates new targets: package and
package_source.  They are ludicrously easy to use, just "make package"
or "make package_source".  It is a good idea to work from a clean
build based on a clean export from svn before doing this.

@section yarp_build_structure_doc conf/YarpDoc.cmake

Here we check if the "doxygen" program is available, and if so we
set up a documentation-generating target called "dox".  This is
used to build YARP's documentation.

@section yarp_build_structure_yarpos src/libYARP_OS/CMakeLists.txt

This sets up the YARP_OS target, which is the core YARP library.
Source code is in the src subdirectory, header files are in the
include subdirectory.

If the "BUILTIN_ACE" flag is set, we expect to find source for ACE
in the directory specified by BUILTIN_ACE_SOURCE_DIR.  We add this
source on to YARP source files and compile it as part of the YARP_OS
target.

Our include directory is appended to the YARP_TREE_INCLUDE_DIRS
global property for reference by later targets.

We place everything in YARP_TREE_INCLUDE_DIRS in our include path.
At this stage, that should be just our own include directory,
and the directory in which generated header files lie
(see \ref yarp_build_structure_conf).  We also add ACE's include path.

We go ahead and create the YARP_OS target, linking it against
all ACE libraries (ACE itself and system dependencies - pthread,
rt, etc, or whatever the FindACE script decided was needed).

We set up installation, and add the target name to the YARP_LIBS 
global property for later reference.  We also set a property
"INCLUDE_DIRS" of the YARP_OS target, to hold its include
path for later reference.

@section yarp_build_structure_yarpsig src/libYARP_sig/CMakeLists.txt

This sets up the YARP_sig target, for signal processing.
Source code is in the src subdirectory, header files are in the
include subdirectory.  Our include directory is appended to the 
YARP_TREE_INCLUDE_DIRS global property for reference by later targets.

We place everything in YARP_TREE_INCLUDE_DIRS in our include path.
We also add ACE's include path, since we use ACE in our implementation.

We create the YARP_sig target, linking it against YARP_OS.

We set up installation, and add the target name to the YARP_LIBS 
global property for later reference.  We also set a property
"INCLUDE_DIRS" of the YARP_sig target, to hold its include
path for later reference.

@section yarp_build_structure_yarpmath src/libYARP_math/CMakeLists.txt

We follow the pattern of \ref yarp_build_structure_yarpsig
to create the YARP_math library, 
for mathematical operations.  There are a few wrinkles:
\li YARP_math is optional.  We create an option CREATE_LIB_MATH
which defaults to FALSE.  If FALSE, this target is skipped.
\li YARP_math depends on GSL.  We use the conf/FindGSL.cmake script to 
track this dependency down.
\li YARP_math optionally can use Atlas with GSL to improve performance
further.  We create an option YARP_USE_ATLAS that default to FALSE.
\li If YARP_USE_ATLAS is set to TRUE, we use the conf/FindAtlas.cmake
script to track this dependency down.
\li Depending on the options, we store the names of the extra libraries 
needed in MATH_LIB_EXTRAS.

The YARP_math target is linked against YARP_sig and YARP_OS, and against
MATH_LIB_EXTRAS.

@section yarp_build_structure_yarpdev src/libYARP_dev/CMakeLists.txt

We follow exactly the pattern of \ref yarp_build_structure_yarpsig
to create the YARP_dev library, for device management.  YARP_dev
links against YARP_sig and YARP_OS.

@section yarp_build_structure_modules src/modules/CMakeLists.txt

This is one of a pair of directories in YARP that contain optional
plugins (the other is src/carriers).  Plugins in YARP are 
handled using a set of macros defined in
\ref yarp_build_structure_plugin "conf/YarpPlugin.cmake".  Thes macros
allow us to create a library (in this case "yarpmod")
containing a lot of optional components using code like this:
\verbatim
BEGIN_PLUGIN_LIBRARY(yarpmod)
  add_subdirectory(cuda)
  add_subdirectory(fakebot)
  ...
END_PLUGIN_LIBRARY(yarpmod)
\endverbatim
The key thing to know is that the "yarpmod" library is a regular
CMake library target, containing some automatically generated code
for initialization, and it has been linked to any and all libraries
created in the listed subdirectories.  We are given 
a list of the linked libraries as ${yarpmod_LIBRARIES}.  
The generated code for this library and the plugins within it
will be placed in a "generated_code" subdirectory of the build.

We add the yarpmod library and the ${yarpmod_LIBRARIES} list to
the global property YARP_LIBS.  This is a variable keeping track
of all the libraries that are configurated to be compiled.
It is needed by \ref yarp_build_structure_describe.

We tell CMake that, upon installing, the yarpmod library should go to 
[prefix]/lib.  We cannot tell it to install the ${yarpmod_LIBRARIES},
since CMake requires that installation should be set up within
the CMake script that creates the target.  YarpPlugin.cmake currently
sets up the install (this may change soon).

There is some moderately complicated code in this file that looks
for extra devices listed in an "ExternalModules.cmake" file.
This is an old mechanism that continues to be supported but for
which there is not much need any more.

@section yarp_build_structure_plugin conf/YarpPlugin.cmake

Here we define macros for creating a "plugin" library that links
to many optional components.

Here are the "user-facing" macros:
\li BEGIN_PLUGIN_LIBRARY(lib_name): this sets a flag called YARP_PLUGIN_MODE
to true, which activates a change of behavior of calls to ADD_LIBRARY and
FIND_PACKAGE (see below).
\li END_PLUGIN_LIBRARY(lib_name): this turns off YARP_PLUGIN_MODE,
and sets up a library target called lib_name that links to all libraries
created after the corresponding call to BEGIN_PLUGIN_LIBRARY.  This
target contains a small piece of generated code to activate all
plugins configured to compile.
\li ADD_PLUGIN_LIBRARY_EXECUTABLE(exec_name lib_name): this creates a
simple test program called exec_name for the plugin library lib_name.
\li PREPARE_DEVICE(dev_name TYPE DeviceClass INCLUDE DeviceClass.h WRAPPER wrapper_name): this generates a CMake flag to select compilation of a
device called "dev_name".  If that CMake flag is turned on, then
this macro generates some code to initialize the named device.  That
code will be included in the next library created (see the ADD_LIBRARY
override below).
\li PREPARE_CARRIER(carrier_name TYPE CarrierClass INCLUDE CarrierClass.h):
this works exactly like PREPARE_DEVICE, except the template for the
generated code is different.

For implementation we also override the following CMake macros:
\li FIND_PACKAGE - we intercept calls to FIND_PACKAGE(YARP), since these won't
work before YARP is compiled.  Such calls are bypassed, and always succeed.  
Otherwise, FIND_PACKAGE's behavior is entirely unchanged.
\li ADD_LIBRARY - we intercept all ADD_LIBRARY calls. If they are not 
import operations (which continue unchanged), then we add the name of
the target to a global list, and call the regular ADD_LIBRARY implementation
with any extra generated code appended to the list of 
source code.  Generated code will be present if calls to 
PREPARE_DEVICE/PREPARE_CARRIER have been made.  If compiling YARP,
we set up installation of the library target.

*
*/
