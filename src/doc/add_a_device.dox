/*
 * Copyright (C) 2010 RobotCub Consortium
 * CopyPolicy: Released under the terms of the GNU GPL v2.0.
 *
 */

/**
 * @page add_a_device How to add a device to YARP

\author Paul Fitzpatrick

In YARP, a device driver is a class that implements one or more 
\ref dev_iface "interfaces".

If you're interested in learning how to use device drivers, see \ref
note_devices, \ref dev_examples, and \ref yarpdev.  If you're read all
that before and are interested in learning how to create devices, then
read on...


\section dev2-howto-intro What is a device driver in YARP?

A device driver should derive from the abstract class
yarp::dev::DeviceDriver. This interface contains methods common to all
device drivers, such as open and close.

Additionally a device driver should implement a selection of other
interfaces that capture what it shares with other families of
devices. For example a camera might implement yarp:dev::IFrameGrabber (a "raw"
interface to the raw data) and/or yarp::dev::IFrameGrabberImage
(a higher-level source of images). For example, 
the yarp::dev::DragonflyDeviceDriver class implements a few of
these interfaces. Interfaces are abstract classes, the idea is that
from outside the user can access a device by using a pointer to the
interface he/she needs, if that interface is supported by the
device. This is quite similar to the way COM works (in a simplified way).

In practice to implement a new device you create a new class which 
derives from DeviceDriver and from the interfacees you want to support, 
and you implement them. The interfaces are documented in the code, 
using the doxygen standard. See \ref note_devices for an example.


\section dev2-howto-steps Step by step instructions

So you want to add a device to YARP?
\li Place your device in a subdirectory of $YARP_ROOT/src/modules.  This isn't actually a requirement, but it is the easiest way to start.  Let us say you pick the directory foo.
\li Get an example that uses your device compiling with CMake in your directory.
\li Split your example into a library part, with contains the device code, and an executable, which exercises the device.  The library part should include at least one class that inherits from yarp::dev::DeviceDriver.  Let's suppose that class is called FooDriver, and is defined in FooDriver.h
\li Just to review, your foo/CMakeLists.txt file might look something like this:
\verbatim
  FIND_PACKAGE(YARP REQUIRED)
  ... find and use other needed libraries ...
  ADD_LIBRARY(foodev FooDriver.cpp FooDriver.h)
  LINK_LIBRARIES(foodev)
  ADD_EXECUTABLE(example FooExample.cpp)
\endverbatim
\li Got all that working?  Good.  When your device gets bundled up with others, YARP will define the CMake "COMPILE_DEVICE_LIBRARY" variable.  So please modify your CMakeLists.txt so that if this variable is set, all it does is add your device library, and skips any testing you might do.
\verbatim
  FIND_PACKAGE(YARP REQUIRED)
  ... find and use other needed libraries ...
  ADD_LIBRARY(foodev FooDriver.cpp FooDriver.h)
  IF (NOT COMPILE_DEVICE_LIBRARY)
    LINK_LIBRARIES(foodev)
    ADD_EXECUTABLE(example FooExample.cpp)
  ENDIF (NOT COMPILE_DEVICE_LIBRARY)
\endverbatim
\li One more thing: YARP needs to keep track of a global list of devices, their names, and other details.  To do this, add in some code like this at the very beginning of your CMakeLists.txt
\verbatim
  IF (COMPILE_DEVICE_LIBRARY)
    PREPARE_DEVICE(foo TYPE FooDriver INCLUDE FooDriver.h)
  ENDIF (COMPILE_DEVICE_LIBRARY)
\endverbatim
\li It is important that this be added *before* the call to ADD_LIBRARY (it generates some code which may be added to your library).  But it is currently considered good practice to add it before searching for any libraries or files, so that you can suppress such searches if the device is not needed by the eventual user.  In that case, the SKIP_foo variable will be set, so you can do:
\verbatim
  IF (COMPILE_DEVICE_LIBRARY)
    PREPARE_DEVICE(foo TYPE FooDriver INCLUDE FooDriver.h)
  ENDIF (COMPILE_DEVICE_LIBRARY)
  IF (NOT SKIP_foo)
    FIND_PACKAGE(YARP REQUIRED)
    ... find and use other needed libraries ...
    ADD_LIBRARY(foodev FooDriver.cpp FooDriver.h)
    IF (NOT COMPILE_DEVICE_LIBRARY)
      LINK_LIBRARIES(foodev)
      ADD_EXECUTABLE(example FooExample.cpp)
    ENDIF (NOT COMPILE_DEVICE_LIBRARY)
  ENDIF (NOT SKIP_foo)
\endverbatim
\li To actually try compiling your device, edit $YARP_ROOT/src/modules/CMakeLists.txt and add in where all the similar lines are:
\verbatim
  ADD_SUBDIRECTORY(foo)
\endverbatim
\li (Alternatively, you can copy $YARP_ROOT/src/modules/CMakeLists.txt to some other directory, remove all the other ADD_SUBDIRECTORY lines and just leave your own)
\li Now run cmake in the modules directory, and then compile.  You should get a library called "yarpmod" and a test program called "yarpmoddev".  If you run "yarpmoddev --list" you should see your device listed.
\li You can also rebuild the YARP library.  If you set the CREATE_DEVICE_LIBRARY_MODULES variable, an option for your new device should show up.

\section add_device_full Full example CMakeLists.txt

Here's an example CMakeLists.txt for the cuda device in $YARP_ROOT/src/modules/cuda:
\verbatim
  IF (COMPILE_DEVICE_LIBRARY)
    PREPARE_DEVICE(cuda TYPE CUDAGPU INCLUDE "CUDADeviceDriver.h")
  ENDIF (COMPILE_DEVICE_LIBRARY)
 
  IF (NOT SKIP_cuda)
    FIND_PACKAGE(YARP REQUIRED)
    FIND_LIBRARY(lib_cudart cudart)
    FIND_LIBRARY(lib_cuda cuda)
    FIND_LIBRARY(lib_cutil cutil)
    FIND_LIBRARY(lib_GL GL)
    SET (OK FALSE)
      IF(lib_cudart AND lib_cuda AND lib_cutil AND lib_GL)
      SET (OK TRUE)
    ENDIF(lib_cudart AND lib_cuda AND lib_cutil AND lib_GL)
    IF (OK)
      LINK_LIBRARIES(${lib_cudart} ${lib_cuda} ${lib_GL} ${lib_cutil})
      ADD_LIBRARY(ycuda CUDADeviceDriver.cpp CUDADeviceDriver.h FunctionClass.h)
    ELSE (OK)
      MESSAGE(STATUS "could not find all libraries needed by cuda driver")
    ENDIF (OK)
  ENDIF (NOT SKIP_cuda)
\endverbatim

Note that YARP device CMakeLists.txt files should always be usable in stand-alone form for testing.

The cuda directory is referenced by a call to ADD_SUBDIRECTORY in $YARP_ROOT/src/modules/CMakeLists.txt

\section add_device_merge Merging bundles of devices from other projects
Suppose your project has a directory $ICUB_ROOT/src/modules that
contains devices not in YARP but compatibile with it.
The easiest way to merge it with YARP durng compilation is by creating a file:
\verbatim
  $YARP_ROOT/conf/ExternalModules.cmake
\endverbatim
with the following content:
\verbatim
  SET(EXTERNAL_MODULES iCub)
  SET(iCub_DIR "$ENV{ICUB_ROOT}/src/modules")
\endverbatim
(this assumes ICUB_ROOT is set in your environment, and points to the iCub repository.  You can merge in many bundles if you wish:
\verbatim
  SET(EXTERNAL_MODULES iCub james)
  SET(iCub_DIR "$ENV{ICUB_ROOT}/src/modules")
  SET(james_DIR "$ENV{JAMES_ROOT}/src/modules")
\endverbatim
Now run cmake (delete the cache!) to generate your project files. You should see a list of devices that can be enabled/disabled on request. Close cmake and compile yarp.  Test that the new devices have been included in YARP by running:

\verbatim
  yarpdev --list
\endverbatim

\section add_device_independent Adding devices without recompiling YARP

There's lots of ways to do this.  Suppose you have a bundle of devices in $YOUR_ROOT/src/modules, compiling to a library called "mymod", and you want to use them in a program in $YOUR_ROOT/app.  Your $YOUR_ROOT/app/CMakeLists.txt could look like this:

\verbatim
  FIND_PACKAGE(YARP REQUIRED)
  SET(mymod_DIR $ENV{YOUR_ROOT}/src/modules)
  IMPORT_DEVICES(devices.h mymod)
  ADD_EXECUTABLE(foo foo.cpp devices.h)
\endverbatim

Then in your code do:

\code
  #include "devices.h"   // automatically generated header
  int main() {
   yarp::dev::DriverCollection dev;  // initializes custom devices...
   ...
  }
\endcode

Your devices are now available in code via PolyDriver etc.

If you don't want the IMPORT_DEVICES stuff, then linking your devices with YARP is the best option.

Your device should show up in the list.  To learn more about
using devices from code, see \ref note_devices, and the 
examples in example/dev.

**/
