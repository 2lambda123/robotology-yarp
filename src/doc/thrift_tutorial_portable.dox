/**
*
@page thrift_tutorial_portable Thrift IDL in YARP: writing a portable

\author Lorenzo Natale

YARP built-in types can be sent through Ports. Sometimes you need to send custom datatypes, in YARP objects that can be sent through ports are called \em portable objects. \ref port_expert shows how you can manually implement a portable object. This tutorial shows how you can automate this process using the Thirft compiler. 

\section sec_intro Introduction

Suppose we have two modules that wish to share a \em SharedData \m struct that contains a string and a vector. Normally you would define the data in a C++ header file and write serialization/deserialization methods to allow it to be sent and received to/from a port (this process is called marshalling/demarshalling). This process requires some YARP specific expertise, is error-prone and tedious. The idea here is that instead of manully writing the class you define the structure using an intermediate language (the Thrift IDL language), then you ask a compiler (the yarpidl_thrift compiler) to generate the class for you, including all the required code.

Let's see how to do it.

\section sec_thirft Thrift definition for SharedData

We start by defining our \em ShareData structure. Open a text editor and type the following:

\code

struct SharedData {
  1: string text;
  2: list<double> content;
}

\endcode

name this file \em SharedData.thrift save and close it.

In thrift's syntax this specifies that SharedData is a struct that contains a \em text field of type \em string and a \em content field which type is a \em vector of floats. Thirft in fact supports much more options, see \ref thrift_tutorial.

Now the \em yarpidl_thrift compiler can be invoked to generate both SharedData.h and SharedData.cpp. 

Type:

\code 

yarpidl_thrift --gen yarp --out ./ SharedData.thrift

\endcode

This will generate two files: \em SharedData.h \em and \em SharedData.cpp \em. 

In case you are interested you can inspect them to see that they define a C++ class with some extra code. The good thing is that you don't actually need to bother about the details, but you can readily use the class in your code.

Now we can use these files in a YARP program.

\section sec-code Code

This code is strightforward. We define a simple sender executable that open a port and periodically write a SharedData object. 

As usual we start with the CMake code, write your CMakeLists.txt:

\code

cmake_minimum_required(VERSION 2.8.7)

find_package(YARP REQUIRED)

include_directories(${CMAKE_CURRENT_SOURCE_DIR} ${YARP_INCLUDE_DIRS})

add_executable(sender sender.cpp SharedData.cpp)
target_link_libraries(sender ${YARP_LIBRARIES})

\endcode

Now we write the code for the sender in \em sender.cpp:

\code


#include "SharedData.h"
#include <iostream>
#include <yarp/os/Network.h>
#include <yarp/os/BufferedPort.h>
#include <yarp/os/Time.h>

using namespace std;

int main()
{
   yarp::os::Network network;

   yarp::os::Port port;

   if (!port.open("/sender"))
   {
       cerr<<"Error opening port, check your yarp network\n";
       return -1;
   }

   cout<<"Starting sender\n";
   
   while(true)
   {
      SharedData d;

      // d.text is a string
      d.text="Hello from sender";

      //d.content is a vector, let's push some data
      d.content.push_back(0.0);
      d.content.push_back(0.0);

      port.write(d);

      yarp::os::Time::delay(0.1);
   }
  
   return 0;
}

\endcode

Now compile the code
\code
mkdir build
cd build
cmake ../
make

./sender
\endcode

Now you can run yarp read on a separate console to inspect the content that is being transmitted on the port, the output should be something like this:
\code
~$ yarp read ... /sender
yarp: Port /tmp/port/1 active at tcp://127.0.0.1:10003
yarp: Receiving input from /sender to /tmp/port/1 using tcp
"Hello from sender" (0.0 0.0)
"Hello from sender" (0.0 0.0)
\endcode

It is simple to write a receiver to do the same programmatically:

Append the following to the CMakeLists.txt

\code
add_executable(receiver receiver.cpp SharedData.cpp)
target_link_libraries(receiver ${YARP_LIBRARIES})
\endcode

This is the receiver code in \em receiver.cpp:

\code

#include <SharedData.h>
#include <iostream>
#include <yarp/os/Network.h>
#include <yarp/os/BufferedPort.h>

using namespace std;

int main()
{
   yarp::os::Network network;

   cout<<"Starting receiver\n";

   yarp::os::Port port;
   if (!port.open("/receiver"))
   {
       cerr<<"Error opening port, check your yarp network\n";
       return -1;
   }

   while(true)
   {
       SharedData d;
       port.read(d);

       //access d
       
   }
   
   return 0;
}

\endcode

\section sec_using-cmake Using CMake 

YARP provides CMake supports to automate the invokation of yarpidl_thrift. This is convenient in large projects when we generate several files and we do not want to keep track of all of them individually.

Edit the file CMakeLists.txt:

\code 

cmake_minimum_required(VERSION 2.8.7)

#find YARP
find_package(YARP REQUIRED)
list(APPEND CMAKE_MODULE_PATH ${YARP_MODULE_PATH})
include(YarpIDL)

\endcode

The last two lines load support for the YarpIDL compiler. 

We now tell CMake to parse SharedData.thrift with the thrift compiler. All generated files will be placed in separate \em include and \em src directories.

\code

#compile definition file to generate source code into the desired directory
set(generated_libs_dir "${CMAKE_CURRENT_SOURCE_DIR}")
yarp_idl_to_dir(SharedData.thrift ${generated_libs_dir})

\endcode

The first time you run CMake it will produce a file SharedData_thrift.cmake that contains all generated files. This file can be used to compile our executables, i.e.:

\code
#include files generated previously
include(SharedData_thrift.cmake)
include_directories(${generated_libs_dir}/include ${YARP_INCLUDE_DIRS})

# create the sender
add_executable(sender sender.cpp ${headers} ${sources})
TARGET_LINK_LIBRARIES(sender ${YARP_LIBRARIES})

# create the receiver
add_executable(receiver receiverr.cpp ${headers} ${sources})
TARGET_LINK_LIBRARIES(receiver ${YARP_LIBRARIES})

\endcode

Now you just have to execute CMake. The variable ALLOW_IDL_GENERATION controls if the thrift compiler is executed to generate SharedData.h/cpp or not. Notice that the first time you run cmake you \em have to enable this flag otherwise compilation will fail because SharedData.h and SharedData.cpp will be missing.

\code
cd build
cmake ../ -DALLOW_IDL_GENERATION=TRUE
\endcode

The code generation step is required only when \em SharedData.thrift is modified.

See code in: example/idl/portable
*
**/
